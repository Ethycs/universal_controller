// ============================================
// ELEMENT PATH - Stable DOM element addressing
// ============================================

/**
 * Provides stable, human-readable paths for DOM elements.
 * Priority: id > data-testid > aria-label > nth-child index.
 * Paths are cached via WeakMap for fast repeated lookups.
 */

const pathCache = new WeakMap();

/**
 * Generate a stable path string for a DOM element.
 * Prefers unique identifiers (id, data-testid, aria-label) over positional indexing.
 *
 * @param {HTMLElement} el - The element to generate a path for.
 * @returns {string} A path string like "DIV#main>FORM[data-testid=login]>INPUT[0]"
 */
export function getElementPath(el) {
  if (!el || el === document.body || el === document.documentElement) return '';

  const cached = pathCache.get(el);
  if (cached) return cached;

  const parts = [];
  let current = el;

  while (current && current !== document.body && current.parentElement) {
    const segment = buildSegment(current);
    parts.unshift(segment);
    current = current.parentElement;
  }

  const path = parts.join('>');
  pathCache.set(el, path);
  return path;
}

/**
 * Build a single path segment for an element.
 * Uses the most stable identifier available.
 *
 * @param {HTMLElement} el
 * @returns {string}
 */
function buildSegment(el) {
  const tag = el.tagName;

  // Best: unique id
  if (el.id) {
    return `${tag}#${el.id}`;
  }

  // Good: data-testid (common in React/testing)
  const testId = el.getAttribute('data-testid');
  if (testId) {
    return `${tag}[data-testid=${testId}]`;
  }

  // Decent: aria-label (if unique among siblings)
  const ariaLabel = el.getAttribute('aria-label');
  if (ariaLabel && el.parentElement) {
    const siblings = [...el.parentElement.children].filter(
      s => s.tagName === tag && s.getAttribute('aria-label') === ariaLabel
    );
    if (siblings.length === 1) {
      return `${tag}[aria-label=${ariaLabel}]`;
    }
  }

  // Decent: name attribute (forms)
  const name = el.getAttribute('name');
  if (name && el.parentElement) {
    const siblings = [...el.parentElement.children].filter(
      s => s.tagName === tag && s.getAttribute('name') === name
    );
    if (siblings.length === 1) {
      return `${tag}[name=${name}]`;
    }
  }

  // Fallback: positional index among siblings
  if (el.parentElement) {
    const idx = [...el.parentElement.children].indexOf(el);
    return `${tag}[${idx}]`;
  }

  return tag;
}

/**
 * Resolve a path string back to a DOM element.
 * Handles id-based segments directly, falls back to walking the tree.
 * Returns null if the element can't be found (stale path).
 *
 * @param {string} path - A path string generated by getElementPath().
 * @returns {HTMLElement|null}
 */
export function resolveElement(path) {
  if (!path) return null;

  const segments = path.split('>');

  // Quick path: if any segment has an id, start from there
  for (let i = segments.length - 1; i >= 0; i--) {
    const idMatch = segments[i].match(/^(\w+)#(.+)$/);
    if (idMatch) {
      const el = document.getElementById(idMatch[2]);
      if (el && el.tagName === idMatch[1]) {
        // Walk forward from this element if there are segments after it
        if (i === segments.length - 1) return el;
        return walkForward(el, segments.slice(i + 1));
      }
    }
  }

  // Full walk from body
  let current = document.body;
  for (const segment of segments) {
    const child = matchChild(current, segment);
    if (!child) return null;
    current = child;
  }

  return current;
}

/**
 * Walk forward through remaining path segments from a starting element.
 *
 * @param {HTMLElement} start
 * @param {string[]} segments
 * @returns {HTMLElement|null}
 */
function walkForward(start, segments) {
  let current = start;
  for (const segment of segments) {
    const child = matchChild(current, segment);
    if (!child) return null;
    current = child;
  }
  return current;
}

/**
 * Find a child of `parent` matching the given path segment.
 *
 * @param {HTMLElement} parent
 * @param {string} segment
 * @returns {HTMLElement|null}
 */
function matchChild(parent, segment) {
  if (!parent) return null;

  // TAG#id
  const idMatch = segment.match(/^(\w+)#(.+)$/);
  if (idMatch) {
    const el = document.getElementById(idMatch[2]);
    return (el && el.tagName === idMatch[1]) ? el : null;
  }

  // TAG[attr=value]
  const attrMatch = segment.match(/^(\w+)\[(\w[\w-]*)=(.+)\]$/);
  if (attrMatch) {
    const [, tag, attr, value] = attrMatch;

    // Positional index (numeric value, no attr name prefix like data-testid)
    if (attr === '' || /^\d+$/.test(`${attr}=${value}`.replace(/.*=/, ''))) {
      // Re-check: could be attr=value or TAG[n]
    }

    for (const child of parent.children) {
      if (child.tagName === tag && child.getAttribute(attr) === value) {
        return child;
      }
    }
    return null;
  }

  // TAG[index] (positional)
  const idxMatch = segment.match(/^(\w+)\[(\d+)\]$/);
  if (idxMatch) {
    const [, tag, idx] = idxMatch;
    const index = parseInt(idx, 10);
    let count = 0;
    for (const child of parent.children) {
      if (child.tagName === tag || true) {
        // Index is among ALL children, not just same-tag siblings
        if ([...parent.children].indexOf(child) === index) {
          return child;
        }
      }
    }
    // Direct index fallback
    return parent.children[index] || null;
  }

  // Plain TAG
  for (const child of parent.children) {
    if (child.tagName === segment) return child;
  }

  return null;
}

/**
 * Clear the path cache. Call this after significant DOM mutations.
 */
export function clearPathCache() {
  // WeakMap entries are automatically GC'd, but we can replace
  // the cache if needed for bulk invalidation. Since WeakMap
  // doesn't support iteration, a full clear requires replacement.
  // For now, individual entries are invalidated by element GC.
}
